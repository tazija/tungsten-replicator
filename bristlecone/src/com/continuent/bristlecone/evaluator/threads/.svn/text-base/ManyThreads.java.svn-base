/**
 * Bristlecone Test Tools for Databases
 * Copyright (C) 2006-2007 Continuent Inc.
 * Contact: bristlecone@lists.forge.continuent.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of version 2 of the GNU General Public License as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
 *
 * Initial developer(s): Robert Hodges and Ralph Hannus.
 * Contributor(s):
 */

package com.continuent.bristlecone.evaluator.threads;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;

import junit.framework.TestCase;

import org.apache.log4j.Logger;

/**
 * <p>
 * This test program is meant to test all varieties of JDBC statement execution,
 * Statement.execute(), Statement.executeQuery, etc) when backends are disabled
 * or are being enabled or disabled under load.
 * </p>
 * <p>
 * This program will ensure that all required tables and procedures are
 * available in your database.<br />
 * It does assumes that the test environment has already been set up.
 * </p>
 * <ul>
 * <li> Test cluster environment has two controllers.</li>
 * <li> Each controller should have one backend database.</li>
 * <li>It must be possible to stop the server for one backend without stopping
 * the other.</li>
 * <li>Three different URLs are used for testing.</li>
 * <li>One that specifies both controllers and two others that specify a single
 * controller.</li>
 * <li>The single controller URLs let us direct requests through known paths.</li>
 * <li> Until controller and server control scripts are available for scluster,
 * enabling and disabling is handled manually by the operator when prompted.</li>
 * </ul>
 * <p>
 * This test is configured through two properties files.<br />
 * One file specifies the test environment properties such as the IP addresses
 * and ports used to communicate with the controllers.<br />
 * The other file specifies the backend specific DDL used to create the test
 * environment.
 * </p>
 * <p>
 * A single table, many_threads, is used for all queries in this test.</br> The
 * table definition is:
 * </p>
 * <pre><code>
 * create table many_threads
 * (
 *  a int primary key,
 *  b varchar(255),
 *  value int
 * )
 * </pre></code>
 * <p>
 * All threads are executing the same set of statements, although jdbc statment
 * type (Statementm, PreparedStatement or CallableStatement) and methods
 * (execute, executeQuery, executeUpdate) is different for each thread.<br />
 * The key in the statements is a sequential number generated by the test.<br />
 * The statement flow is:
 * </p>
 * 
 * <pre><code>
 * insert into many_threads values(key, 'id string', 0)
 * select a from many_threads where a = key
 * update many_threads set value = a * a where a = key + 1
 * </code></pre>
 * 
 * <p>
 * At the end of the test run, value is either 0 or a * a depending on the
 * sequence of operations between simultaneously executing threads.<br />
 * Two orderings are possible:
 * </p>
 * <pre><code>
 *  1:
 * 
 *          A                                   B
 *    insert (1, 'A', 0)                   insert (2, 'B', 0)
 *    select a                             select a
 *    update set value = 4 where a = 2     update set value = 9 where a = 3 
 *    
 *  2:
 *          A                                   B
 * 
 *    insert (1, 'A', 0)                   
 *    select a                             
 *    update set value = 4 where a = 2        
 *                                         insert (2, 'B', 0)   
 *                                         select a    
 *                                         update set value = 9 where a = 3 
 * </pre></code>
 * <p>
 * In the second case value is 0 when a is 2, because the update happened before
 * the insert. Therefore, if transactions are executed in different orders on
 * different backends, the sum of value will be different in the different
 * backends.
 * </p>
 */
public class ManyThreads extends TestCase
{
  private static final int      MAX_KEY_VALUE = 1000;
  private static Logger         logger        = Logger
                                                  .getLogger(ManyThreads.class);
  private static BufferedReader in;
  private static Properties     props;
  private static boolean        clearAll;
  private static int            nextKey       = 0;
  private String                testId;
  private ArrayList<String>     failures      = new ArrayList<String>();
  private static String[]       methods       = {"doStatementQueryAndUpdate",
      "doStatementExecute", "doPreparedStatementQueryAndUpdate",
      "doPreparedStatementExecute", "doCallableStatementQueryAndUpdate",
      "doCallableStatementExecute"            };
  private Object                sync          = new Object();
  private volatile boolean      paused        = true;

  private boolean               stopped       = false;
  private static Config         config;
  private Thread[]              threads;
  private volatile int          pausedCount;

  /**
   * This class is a holder for the static configuration information.
   */
  private static class Config
  {

    private String   urlone;
    private String   urltwo;
    private String   url;
    private String   user;
    private String   password;
    private boolean  hasProcedures;
    private String[] urls;

    /**
     * Constructs the ManyThreads.config based on the given properties object.
     * 
     * @param testProperties the test environment specific properties.
     * @throws Exception if the backend specific properties file is not
     *           available or if the jdbc driver class is not available.
     */
    public Config(Properties testProperties) throws Exception
    {

      String clusterProperties = testProperties
          .getProperty("cluster.properties");
      Properties clusterProps = new Properties();
      InputStream is = ClassLoader.getSystemResourceAsStream(clusterProperties);
      clusterProps.load(is);
      is.close();
      String clusterType = clusterProperties.substring(0, clusterProperties
          .indexOf('.'));
      props = new Properties();
      props.putAll(clusterProps);
      props.putAll(testProperties);
      urlone = "jdbc:" + clusterType + "://"
          + props.getProperty("controllerOne.address") + ":"
          + props.getProperty("controllerOne.jdbcPort") + "/"
          + props.getProperty("vdb");
      urltwo = "jdbc:" + clusterType + "://"
          + props.getProperty("controllerTwo.address") + ":"
          + props.getProperty("controllerTwo.jdbcPort") + "/"
          + props.getProperty("vdb");
      url = "jdbc:" + clusterType + "://"
          + props.getProperty("controllerOne.address") + ":"
          + props.getProperty("controllerOne.jdbcPort") + ","
          + props.getProperty("controllerTwo.address") + ":"
          + props.getProperty("controllerTwo.jdbcPort") + "/"
          + props.getProperty("vdb");
      urls = new String[]{url, urlone, urltwo};
      user = props.getProperty("login");
      password = props.getProperty("password");
      in = new BufferedReader(new InputStreamReader(System.in));
      Class.forName("com.continuent." + clusterType + ".driver.Driver");
      hasProcedures = props.containsKey("create.insertProc");
      String clear = props.getProperty("clear");
      clearAll = clear != null && clear.toLowerCase().equals("true");
      String driver = props.getProperty("backend.driver");
      assertNotNull("The class name for the backend driver is required:",
          driver);
      Class.forName(driver);
    }
  }

  /**
   * Default contructor for ManyThreads. It loads configuration information from
   * a properties file. The name of the properties file can be specified with
   * the "test.properties" System property. The default value is
   * "test.properties". See the test.properties.sample file the definition of
   * the expected properties.
   * 
   * @throws Exception when the specified configuration property file canoot be
   *           read.
   */
  public ManyThreads() throws Exception
  {
    if (config == null)
    {
      String propsFile = System.getProperty("test.properties",
          "test.properties");
      InputStream is = ClassLoader.getSystemResourceAsStream(propsFile);
      Properties temp = new Properties();
      temp.load(is);

      is.close();
      config = new Config(temp);
    }

    threads = new Thread[methods.length * config.urls.length];
  }

  /**
   * @param props
   * @throws Exception
   */
  public ManyThreads(Properties props) throws Exception
  {
    if (config == null)
    {
      config = new Config(props);

    }

    threads = new Thread[methods.length * config.urls.length];
  }

  protected void tryClearAll(String url) throws Exception
  {
    Connection conn = null;
    try
    {
      conn = getConnection(url);
      conn.setAutoCommit(true);
      Statement s = conn.createStatement();
      if (config.hasProcedures)
      {
        if (isStoredProcedureAvailable(conn, "insert_many_threads"))
          s.execute(props.getProperty("drop.insertProc"));
        if (isStoredProcedureAvailable(conn, "update_many_threads"))
          s.execute(props.getProperty("drop.updateProc"));
        if (isStoredProcedureAvailable(conn, "delete_many_threads"))
          s.execute(props.getProperty("drop.deleteProc"));
        if (isStoredProcedureAvailable(conn, "select_many_threads"))
          s.execute(props.getProperty("drop.selectProc"));
        s.execute(props.getProperty("delete.sequoia.base"));
        s.execute(props.getProperty("delete.sequoia.references"));
      }
      s.execute(props.getProperty("drop.table"));
      clearAll = false;
    }
    finally
    {
      if (conn != null)
      {
        conn.close();
      }
    }
  }

  /**
   * Depending on the state of the backend databases. It may be nessecary to try
   * more than one URL in order to successfully complete setup.
   * 
   * @param url
   * @throws Exception
   */
  protected void trySetUp(String url) throws Exception
  {
    logger.debug("Full url: " + url);

    Connection conn = null;
    try
    {
      conn = getConnection(url);
      conn.setAutoCommit(true);
      Statement s = conn.createStatement();
      if (!isTableAvailable(conn, "many_threads"))
      {
        s.execute(props.getProperty("create.table"));
      }

      s.execute(props.getProperty("truncateTable"));

      if (config.hasProcedures)
      {
        if (!isTableAvailable(conn, "sequoiaSABase"))
        {
          s.execute(props.getProperty("sequoia.base"));
        }
        if (!isRowAvailable(s,
            "select objectName from sequoiaSABase where objectName = 'insert_many_threads'"))
          s
              .execute("insert into sequoiaSABase values('insert_many_threads', 1, '2006-03-30', 2, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0)");
        if (!isRowAvailable(s,
            "select objectName from sequoiaSABase where objectName = 'update_many_threads'"))
          s
              .execute("insert into sequoiaSABase values('update_many_threads', 1, '2006-03-30', 2, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0)");
        if (!isRowAvailable(s,
            "select objectName from sequoiaSABase where objectName = 'delete_many_threads'"))
          s
              .execute("insert into sequoiaSABase values('delete_many_threads', 1, '2006-03-30', 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0)");
        if (!isRowAvailable(s,
            "select objectName from sequoiaSABase where objectName = 'select_many_threads'"))
          s
              .execute("insert into sequoiaSABase values('select_many_threads', 1, '2006-03-30', 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1)");

        if (!isTableAvailable(conn, "sequoiaSAReferences"))
        {
          s.execute(props.getProperty("sequoia.references"));
        }

        if (!isRowAvailable(
            s,
            "select objectName from sequoiaSAReferences where baseObjectName = 'insert_many_threads'"))
          s
              .execute("insert into sequoiaSAReferences values('insert_many_threads', 'many_threads', 2, 0, 1, 0, 0, 0, 1, 0)");
        if (!isRowAvailable(
            s,
            "select objectName from sequoiaSAReferences where baseObjectName = 'update_many_threads'"))
          s
              .execute("insert into sequoiaSAReferences values('update_many_threads', 'many_threads', 2, 0, 0, 1, 0, 0, 1, 0)");
        if (!isRowAvailable(
            s,
            "select objectName from sequoiaSAReferences where baseObjectName = 'delete_many_threads'"))
          s
              .execute("insert into sequoiaSAReferences values('delete_many_threads', 'many_threads', 2, 0, 0, 0, 1, 0, 1, 0)");

        if (!isStoredProcedureAvailable(conn, "insert_many_threads"))
        {
          s.execute(props.getProperty("create.insertProc"));
          if (props.getProperty("alter.insertProc") != null)
          {
            s.execute(props.getProperty("alter.insertProc"));
          }
        }
        if (!isStoredProcedureAvailable(conn, "update_many_threads"))
        {
          s.execute(props.getProperty("create.updateProc"));
          if (props.getProperty("alter.updateProc") != null)
          {
            s.execute(props.getProperty("alter.updateProc"));
          }
        }
        if (!isStoredProcedureAvailable(conn, "delete_many_threads"))
        {
          s.execute(props.getProperty("create.deleteProc"));
          if (props.getProperty("alter.deleteProc") != null)
          {
            s.execute(props.getProperty("alter.deleteProc"));
          }
        }
        if (!isStoredProcedureAvailable(conn, "select_many_threads"))
        {
          s.execute(props.getProperty("create.selectProc"));
          if (props.getProperty("alter.selectProc") != null)
          {
            s.execute(props.getProperty("alter.selectProc"));
          }
        }
      }
    }
    finally
    {
      if (conn != null)
      {
        conn.close();
      }
    }
  }

  /**
   * Cycle through all the URLs until the test setup completes cleanly.
   */
  protected void setUp() throws Exception
  {

    super.setUp();
    testId = "test: " + System.currentTimeMillis();
    Exception savedException = null;
    if (clearAll)
    {
      for (int i = 0; i < config.urls.length; i++)
      {
        try
        {
          tryClearAll(config.urls[i]);
          break;
        }
        catch (Exception e)
        {
          savedException = e;
        }
      }
    }

    for (int i = 0; i < config.urls.length; i++)
    {
      try
      {
        trySetUp(config.urls[i]);
        return;
      }
      catch (Exception e)
      {
        savedException = e;
      }
    }

    throw savedException;
  }

  protected void tearDown() throws Exception
  {
    super.tearDown();
  }

  protected Connection getConnection(String url) throws SQLException
  {
    try
    {
      Connection c = DriverManager.getConnection(url, config.user,
          config.password);
      // c.setAutoCommit(false);
      return c;
    }
    catch (SQLException e)
    {
      logger.debug("Connection error: " + e.getMessage());
      throw e;
    }
  }

  /**
   * Determine whether or not the specified table exists in the database.
   * 
   * @param conn
   * @param tableName
   * @return
   * @throws SQLException
   */
  private boolean isTableAvailable(Connection conn, String tableName)
      throws SQLException
  {
    ResultSet rs = conn.getMetaData().getTables(null, "%", tableName,
        new String[]{"TABLE"});
    boolean result = rs.next();
    rs.close();
    if (!result)
    {
      rs = conn.getMetaData().getTables(null, "%", tableName.toLowerCase(),
          new String[]{"TABLE"});
      result = rs.next();
    }
    rs.close();
    return result;
  }

  private boolean isStoredProcedureAvailable(Connection conn, String procName)
      throws SQLException
  {
    ResultSet rs = conn.getMetaData().getProcedures(null, "%", procName);
    boolean result = rs.next();
    rs.close();
    if (!result)
    {
      rs = conn.getMetaData().getProcedures(null, "%", procName.toLowerCase());
      result = rs.next();
    }
    rs.close();
    return result;
  }

  private boolean isRowAvailable(Statement s, String query) throws SQLException
  {
    ResultSet rs = s.executeQuery(query);
    boolean result = rs.next();
    rs.close();
    return result;
  }

  /**
   * Retrieves the average of the value column from the specified database.
   * 
   * @param url
   * @param login
   * @param password
   * @return
   * @throws Exception
   */
  private int checkABackend(String url, String login, String password)
      throws Exception
  {
    Connection conn = null;
    try
    {
      conn = getConnection(url);
      Statement s = conn.createStatement();
      int result = executeQuery(s, "select sum(value) as a from many_threads");
      s.close();
      return result;
    }
    finally
    {
      close(conn);
    }
  }

  /**
   * Verifies that the values in both backend databases are the same. The
   * average of the value column is used for the comparison. Value is either 0
   * or a * a depending on the order of statement execution between threads.
   * 
   * @throws Exception if an error occurs while retreiving the data.
   */
  private void checkBackends() throws Exception
  {

    String url = props.getProperty("backend1.url");
    int b1 = 0;
    if (url != null)
    {
      b1 = checkABackend(url, config.user, config.password);
      logger.debug("Backend 1 sum of value:" + b1);
      url = props.getProperty("backend2.url");
      if (url != null)
      {
        int b2 = checkABackend(url, config.user, config.password);

        logger.debug("Backend 2 sum of value:" + b2);
        assertEquals(b1, b2);
      }
      url = props.getProperty("backend3.url");
      if (url != null)
      {
        int b3 = checkABackend(url, config.user, config.password);

        logger.debug("Backend 3 sum of value:" + b3);
        assertEquals(b1, b3);
      }
    }
    else
    {
      logger.debug("No backend url provided - Skipping consistency checks");
    }
  }

  /**
   * Executes a query using Statement.execute(String). Returning either an
   * update count or the value of the first row of the first resultset depending
   * on the setting of expectRs flag.
   * 
   * @param s the Statement object to test
   * @param command the query to execute
   * @param expectRs indicates whether the execution should produce a ResultSet
   *          or an update count.
   * @return the requested value
   * @throws SQLException
   */
  private int execute(Statement s, String command, boolean expectRs)
      throws SQLException
  {
    boolean hasResultSet = s.execute(command);
    int count = 0;
    while (hasResultSet || count >= 0)
    {
      if (hasResultSet)
      {
        ResultSet rs = s.getResultSet();
        if (expectRs)
        {
          if (rs.next())
          {
            count = rs.getInt("a");
          }
          else
          {
            count = -1;
          }
        }
        else
        {
          logger.warn("Unexpected result set for: '" + command + "'");
        }
        rs.close();
        break;
      }
      else
      {
        count = s.getUpdateCount();
        return count;
      }
    }

    return count;
  }

  /**
   * Uses the Statement.execute() method to execute a prepared SQL statement.
   * 
   * @param s the statment to execute
   * @param expectRs indicates whether a ResultSet or an update count is
   *          expected
   * @return the value of the first column of the first row of the result set or
   *         the first update count depending on the value of expectRS.
   * @throws SQLException
   */
  private int execute(PreparedStatement s, boolean expectRs)
      throws SQLException
  {
    boolean hasResultSet = s.execute();
    int count = 0;
    while (hasResultSet || count >= 0)
    {
      if (hasResultSet)
      {
        ResultSet rs = s.getResultSet();
        if (expectRs)
        {
          if (rs.next())
          {
            count = rs.getInt(1);
          }
          else
          {
            count = -1;
          }
        }
        else
        {
          logger.warn("Unexpected result set for: '" + s + "'");
        }
        rs.close();
        break;
      }
      else
      {
        count = s.getUpdateCount();
        if (!expectRs || count < 0)
          return count;
      }
      hasResultSet = s.getMoreResults();
    }

    return count;
  }

  /**
   * Executes a query returning a result set.
   * 
   * @param s
   * @param query
   * @return
   * @throws SQLException
   */
  private int executeQuery(Statement s, String query) throws SQLException
  {
    ResultSet rs = s.executeQuery(query);
    if (rs.next())
    {
      return rs.getInt("a");
    }

    return -1;
  }

  private int executeQuery(PreparedStatement statement) throws SQLException
  {
    ResultSet rs = statement.executeQuery();
    if (rs.next())
    {
      return rs.getInt(1);
    }

    return -1;
  }

  /**
   * Runs through the standard query sequence using Statement.executeQuery() and
   * Statement.ExecuteUpdate().
   * 
   * @param conn
   * @param id
   * @throws SQLException
   */
  public void doStatementQueryAndUpdate(Connection conn, String id)
      throws SQLException
  {
    try
    {
      int key = getNextKey();
      Statement s1 = conn.createStatement();
      String bValue = "doStatementQueryAndUpdate:" + id + testId;
      if (key >= MAX_KEY_VALUE)
      {
        key = key % MAX_KEY_VALUE;
        s1.executeUpdate("delete from many_threads where a = " + key);
      }
      int count = s1.executeUpdate("insert into many_threads values (" + key
          + ", '" + bValue + "', 0)");
      assertEquals(1, count);
      assertEquals(key, executeQuery(s1,
          "select a from many_threads where a = " + key));
      s1.executeUpdate("update many_threads set value =  a * a, b = b || '&"
          + bValue + "' where a = " + (key + 1));
      s1.close();
      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }
  }

  private synchronized int getNextKey()
  {
    return nextKey++;
  }

  /**
   * Runs through the standard query sequence using Statement.execute().
   * 
   * @param conn
   * @param id
   * @throws SQLException
   */
  public void doStatementExecute(Connection conn, String id)
      throws SQLException
  {
    try
    {
      int key = getNextKey();
      Statement s1 = conn.createStatement();
      String bValue = "doStatementExecute:" + id + testId;
      if (key >= MAX_KEY_VALUE)
      {
        key = key % MAX_KEY_VALUE;
        execute(s1, "delete from many_threads where a = " + key, false);
      }
      int count = execute(s1, "insert into many_threads values (" + key + ", '"
          + bValue + "', 0)", false);
      assertEquals(1, count);
      count = execute(s1, "select a from many_threads where a = " + key, true);
      assertEquals(key, count);
      execute(s1, "update many_threads set value = a * a, b = b || '&" + bValue
          + "' where a = " + (key + 1), false);
      s1.close();
      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }
  }

  public void doStatementReader(Connection conn, String id) throws SQLException
  {
    try
    {
      Statement s1 = conn.createStatement();
      s1.execute("select * from many_threads");
      s1.executeQuery("select * from many_threads");
      s1.close();
      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }

  }

  /**
   * Closes a Connection if it exists ignoreing all errors.
   * 
   * @param conn
   */
  private void close(Connection conn)
  {
    if (conn != null)
    {
      try
      {
        conn.close();
      }
      catch (SQLException e)
      {

      }
    }
  }

  /**
   * Test Statement.executeQuery() and Statement.executeUpdate() when a backend
   * is disabled. Queries are forced through each of the controllers.
   * 
   * @throws Exception
   */
  public void testStatements() throws Exception
  {
    System.out.print("Disable backend one and hit enter:");
    in.readLine();
    Connection c1 = null;
    Connection c2 = null;
    try
    {
      c1 = getConnection(config.urlone);
      c2 = getConnection(config.urltwo);
      doStatementQueryAndUpdate(c1, config.urlone);
      doStatementQueryAndUpdate(c2, config.urltwo);
      doStatementExecute(c1, config.urlone);
      doStatementExecute(c2, config.urltwo);
      doStatementReader(c1, config.urlone);
      doStatementReader(c2, config.urltwo);
      System.out.print("Enable the backend and hit enter:");
      in.readLine();
      checkBackends();
    }
    finally
    {
      close(c1);
      close(c2);
    }

  }

  /**
   * Runs through the standard query sequence using
   * PreparedStatement.executeQuery() and PreparedStatement.ExecuteUpdate().
   * 
   * @param conn
   * @param id
   * @throws SQLException
   */
  public void doPreparedStatementQueryAndUpdate(Connection conn, String id)
      throws SQLException
  {
    try
    {
      int key = getNextKey();
      String bValue = "doPreparedStatementQueryAndUpdate:" + id + ":" + testId;
      PreparedStatement s1;
      if (key >= MAX_KEY_VALUE)
      {
        key = key % MAX_KEY_VALUE;
        s1 = conn.prepareStatement("delete from many_threads where a = ?");
        s1.setInt(1, key);
        s1.executeUpdate();
        s1.close();
      }
      s1 = conn.prepareStatement("insert into many_threads values (?, ?, 0)");
      s1.setInt(1, key);
      s1.setString(2, bValue);
      assertEquals(1, s1.executeUpdate());
      s1.close();
      s1 = conn.prepareStatement("select a from many_threads where a = ?");
      s1.setInt(1, key);
      assertEquals(key, executeQuery(s1));
      s1.close();
      s1 = conn
          .prepareStatement("update many_threads set value = a * a, b = b || ? where a = ?");
      s1.setString(1, "&" + bValue);
      s1.setInt(2, key + 1);
      s1.executeUpdate();
      s1.close();
      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }
  }

  public void doPreparedStatementReader(Connection conn, String id)
      throws SQLException
  {
    try
    {
      PreparedStatement s1 = conn
          .prepareStatement("select * from many_threads");
      s1.execute();
      s1.executeQuery();
      s1.close();
      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }

  }

  /**
   * Runs through the standard query sequence using PreparedStatement.execute().
   * 
   * @param conn
   * @param id
   * @throws SQLException
   */
  public void doPreparedStatementExecute(Connection conn, String id)
      throws SQLException
  {
    try
    {
      int key = getNextKey();

      String bValue = "doPreparedStatementExecute:" + id + ":" + testId;
      PreparedStatement s1;
      if (key >= MAX_KEY_VALUE)
      {
        key = key % MAX_KEY_VALUE;
        s1 = conn.prepareStatement("delete from many_threads where a = ?");
        s1.setInt(1, key);
        s1.execute();
        s1.close();
      }
      s1 = conn.prepareStatement("insert into many_threads values (?, ?, 0)");
      s1.setInt(1, key);
      s1.setString(2, bValue);
      assertEquals(1, execute(s1, false));
      s1.close();
      s1 = conn.prepareStatement("select a from many_threads where a = ?");
      s1.setInt(1, key);
      assertEquals(key, execute(s1, true));
      s1.close();
      s1 = conn
          .prepareStatement("update many_threads set value = a * a, b = b || ? where a = ?");
      s1.setString(1, "&" + bValue);
      s1.setInt(2, key + 1);
      execute(s1, false);
      s1.close();
      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }
  }

  /**
   * Tests executing the standard query sequence using prepared statements while
   * a backend is disabled.
   * 
   * @throws Exception
   */
  public void testPreparedStatements() throws Exception
  {
    System.out.print("Disable backend one and hit enter:");
    in.readLine();
    Connection c1 = null;
    Connection c2 = null;
    try
    {
      c1 = getConnection(config.urlone);
      c2 = getConnection(config.urltwo);
      doPreparedStatementQueryAndUpdate(c1, config.urlone);
      doPreparedStatementQueryAndUpdate(c2, config.urltwo);
      doPreparedStatementExecute(c1, config.urlone);
      doPreparedStatementExecute(c2, config.urltwo);
      doPreparedStatementReader(c1, config.urlone);
      doPreparedStatementReader(c2, config.urltwo);
    }
    finally
    {
      close(c1);
      close(c2);
    }
  }

  /**
   * Runs the standard query sequence using CallableStatement.executeQuery() and
   * CallableStatment.executeUpdate. Note: Postgres does not support
   * CallableStatement.executeUpdate so execute is used instead.
   * 
   * @param conn
   * @param id
   * @throws SQLException
   */
  public void doCallableStatementQueryAndUpdate(Connection conn, String id)
      throws SQLException
  {
    try
    {
      int key = getNextKey();

      String bValue = "doCallableStatementQueryAndUpdate:" + id + ":" + testId;
      CallableStatement s1;
      boolean eu = props.getProperty("callablestatement.executeUpate", "true")
          .equals("true");
      if (key >= MAX_KEY_VALUE)
      {
        key = key % MAX_KEY_VALUE;
        s1 = conn.prepareCall("{call delete_many_threads(?)}");
        s1.setInt(1, key);
        s1.execute();
        s1.close();
      }
      s1 = conn.prepareCall("{call insert_many_threads(?, ?)}");
      s1.setInt(1, key);
      s1.setString(2, bValue);
      if (eu)
      {
        assertEquals(1, s1.executeUpdate());
      }
      else
      {
        execute(s1, true);
      }
      s1.close();
      s1 = conn.prepareCall("{call select_many_threads(?)}");
      s1.setInt(1, key);
      assertEquals(key, executeQuery(s1));
      s1.close();
      s1 = conn.prepareCall("{call update_many_threads(?, ?)}");
      s1.setString(1, "&" + bValue);
      s1.setInt(2, key + 1);
      if (eu)
      {
        s1.executeUpdate();
      }
      else
      {
        execute(s1, true);
      }
      s1.close();
      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }
  }

  /**
   * Runs the standard query sequence using CallableStatement.execute().
   * 
   * @param conn
   * @param id
   * @throws SQLException
   */
  public void doCallableStatementExecute(Connection conn, String id)
      throws SQLException
  {
    try
    {
      int key = getNextKey();
      String bValue = "doCallableStatementExecute:" + id + ":" + testId;
      boolean eu = props.getProperty("callablestatement.executeUpate", "true")
          .equals("true");
      CallableStatement s1;
      if (key >= MAX_KEY_VALUE)
      {
        key = key % MAX_KEY_VALUE;
        s1 = conn.prepareCall("{call delete_many_threads(?)}");
        s1.setInt(1, key);
        execute(s1, !eu);
        s1.close();
      }
      s1 = conn.prepareCall("{call insert_many_threads(?, ?)}");
      s1.setInt(1, key);
      s1.setString(2, bValue);

      execute(s1, !eu);
      s1.close();
      s1 = conn.prepareCall("{call select_many_threads(?)}");
      s1.setInt(1, key);
      assertEquals(key, execute(s1, true));
      s1.close();
      s1 = conn.prepareCall("{call update_many_threads(?, ?)}");
      s1.setString(1, "&" + bValue);
      s1.setInt(2, key + 1);
      execute(s1, !eu);
      s1.close();

      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }
  }

  /**
   * Runs a series of read only queries.
   * 
   * @param conn
   * @param id
   * @throws SQLException
   */
  public void doCallableStatementReader(Connection conn, String id)
      throws SQLException
  {
    try
    {
      for (int i = 0; i < 5; i++)
      {
        CallableStatement s1 = conn
            .prepareCall("{call select_many_threads(?)}");
        s1.setInt(1, i);
        execute(s1, true);
        executeQuery(s1);
        s1.close();
      }
      if (!conn.getAutoCommit())
      {
        conn.commit();
      }
    }
    catch (SQLException e)
    {
      if (!conn.getAutoCommit())
      {
        try
        {
          conn.rollback();
        }
        catch (SQLException e2)
        {
        }
      }
    }
  }

  /**
   * Tests executing queries through CallableStatements while a backend is
   * disabled. Queries are forced through each of the controllers.
   * 
   * @throws Exception
   */
  public void testCallableStatements() throws Exception
  {
    if (!config.hasProcedures)
    {
      logger.info("skipping test because no stored procedures are defined");
      return;
    }
    System.out.print("Disable backend one and hit enter:");
    in.readLine();
    Connection c1 = null;
    Connection c2 = null;
    try
    {
      c1 = getConnection(config.urlone);
      c2 = getConnection(config.urltwo);
      doCallableStatementQueryAndUpdate(c1, config.urlone);
      doCallableStatementQueryAndUpdate(c2, config.urltwo);
      doCallableStatementExecute(c1, config.urlone);
      doCallableStatementExecute(c2, config.urltwo);
      doCallableStatementReader(c1, config.urlone);
      doCallableStatementReader(c2, config.urltwo);
    }
    finally
    {
      close(c1);
      close(c2);
    }
  }

  public void testProcDDLRecoveryOrdering() throws Exception
  {
    if (!config.hasProcedures)
    {
      logger.info("skipping test because no stored procedures are defined");
      return;
    }
    Connection c1 = null;
    try
    {
      c1 = getConnection(config.url);
      Statement s1 = c1.createStatement();

      s1.execute("insert into many_threads values(1, 'one ', 0)");
      s1.execute("insert into many_threads values(2, 'two ', 0)");
      if (!c1.getAutoCommit())
      {
        c1.commit();
      }
      System.out.print(getName() + " Disable backend one and hit enter:");
      in.readLine();
      boolean autoCommit = c1.getAutoCommit();
      c1.setAutoCommit(true);
      s1.execute(props.getProperty("drop.updateProc"));
      String create = props.getProperty("create.updateProc");
      s1.execute(create);
      if (props.getProperty("alter.updateProc") != null)
      {
        s1.execute(props.getProperty("alter.updateProc"));
      }

      c1.setAutoCommit(autoCommit);
      // CallableStatement cs = c1.prepareCall("{call
      // update_many_threads('hello', 1)}");
      // cs.execute();
      // cs.close();
      // cs = c1.prepareCall("{call update_many_threads('goodbye', 2)}");
      // cs.execute();
      // cs.close();
      s1.execute("{call update_many_threads('hello', 1)}");
      s1.execute("{call update_many_threads('goodbye', 2)}");
      if (!c1.getAutoCommit())
      {
        c1.commit();
      }
      System.out.print(getName() + " Enable the backend and hit enter:");
      in.readLine();
      checkBackends();
      System.out.print(getName() + " Disable backend one and hit enter:");
      in.readLine();
    }
    finally
    {
      close(c1);
    }
  }

  public void testTableDDLRecoveryOrdering() throws Exception
  {
    Connection c1 = null;
    try
    {

      System.out.print(getName() + " Disable backend one and hit enter:");
      in.readLine();

      c1 = getConnection(config.url);
      Statement s1 = c1.createStatement();
      s1.execute(props.getProperty("drop.table"));
      String create = props.getProperty("create.table");
      s1.execute(create);
      s1.setCursorName("cursorName");
      s1.execute("select * from many_threads for update");
      s1.execute("insert into many_threads values(1, 'one ', 1)");
      s1.execute("insert into many_threads values(2, 'two ', 4)");
      if (!c1.getAutoCommit())
      {
        c1.commit();
      }
      System.out.print(getName() + " Enable the backend and hit enter:");
      in.readLine();
      checkBackends();
    }
    finally
    {
      close(c1);
    }
  }

  /**
   * Creates a Runnable object that will execute the specified method. Once
   * started this thread will run until it gets an error or it is told to stop
   * by the checkContinue() method.
   * 
   * @param methodName
   * @param url
   * @param target
   * @return
   */
  private Runnable makeRunnable(final String methodName, final String url,
      final Object target)
  {
    return new Runnable()
    {
      public void run()
      {
        Connection conn = null;
        if (!config.hasProcedures
            && methodName.indexOf("CallableStatement") >= 0)
        {
          logger
              .info("Thread skipping test because no stored procedures are defined");
          return;
        }
        Method method = null;
        try
        {
          method = ManyThreads.class.getMethod(methodName, new Class[]{
              Connection.class, String.class});
        }
        catch (SecurityException e)
        {
          logger.error("Not allowed", e);
        }
        catch (NoSuchMethodException e)
        {
          logger.error("method not found: " + methodName, e);
        }
        if (method == null)
        {
          return;
        }
        try
        {
          conn = getConnection(url);
          Object[] args = {conn, url};
          while (checkContinue())
          {
            try
            {
              method.invoke(ManyThreads.this, args);
            }
            catch (IllegalArgumentException e)
            {
              logger.fatal(e);
              return;
            }
            catch (IllegalAccessException e)
            {
              logger.fatal(e);
              return;
            }
            catch (InvocationTargetException e)
            {
              logger.error(e.getTargetException());
              logger.debug(e);
              failures.add(methodName + ":" + url);
              break;
            }

            Thread.sleep(100);

          }
        }
        catch (SQLException e)
        {
          logger.error("Could not get connection", e);
          failures.add(methodName + ":" + url);
        }
        catch (InterruptedException e)
        {
          logger.debug(Thread.currentThread().getName()
              + ": Stopping due to interrupt");
        }
        catch (Throwable t)
        {
          failures.add(Thread.currentThread().getName() + t);
        }
        finally
        {
          if (conn != null)
          {
            try
            {
              conn.close();
            }
            catch (SQLException e)
            {
            }
          }
        }
      };
    };
  }

  /**
   * This is the loop control for the test threads. It handles pausing and
   * stopping the threads.
   * 
   * @return
   * @throws InterruptedException
   */
  private boolean checkContinue() throws InterruptedException
  {
    synchronized (sync)
    {
      while (!stopped && paused)
      {
        pausedCount++;
        try
        {
          sync.wait();
        }
        finally
        {
          pausedCount--;
        }
      }

    }

    return !stopped;
  }

  /**
   * Tell the threads to pause or resume.
   * 
   * @param paused
   */
  public void setPaused(boolean paused)
  {
    synchronized (sync)
    {
      this.paused = paused;
      if (!paused)
      {
        sync.notifyAll();
        logger.debug("Threads resumed");
      }
      else
      {
        logger.debug("Pause requested");
      }
    }
  }

  private void waitPaused(int count)
  {
    int waits = 0;
    synchronized (sync)
    {
      while (pausedCount < count)
      {
        try
        {
          sync.wait(100);
        }
        catch (InterruptedException e)
        {
        }
        if (waits++ >= 300)
        {
          fail((count - pausedCount) + " Threads are hung");
        }
      }
      logger.debug("All threads paused: " + pausedCount);
    }
  }

  /**
   * Tell the threads to stop.
   * 
   * @param stopped
   */
  private void setStopped(boolean stopped)
  {
    synchronized (sync)
    {
      this.stopped = stopped;
      if (stopped)
      {
        setPaused(false);
      }
    }
  }

  /**
   * Create a thread for each URL and method combination.
   * 
   * @throws Exception
   */
  public void createThreads() throws Exception
  {

    setPaused(true);

    int index = 0;
    for (int m = 0; m < methods.length; m++)
    {
      for (int u = 0; u < config.urls.length; u++)
      {
        Runnable r = makeRunnable(methods[m], config.urls[u], this);
        Thread t = new Thread(r);
        t.setName(methods[m] + ":" + config.urls[u]);
        threads[index++] = t;
      }
    }
    for (int i = 0; i < threads.length; i++)
    {
      threads[i].start();
    }
  }

  /**
   * Stop the threads and return a list of threads that had failures. Threads
   * that do not stop are assumed to be hung on a operation in the controller.
   */
  public List stopThreads()
  {
    setStopped(true);

    long waitTime = 30000;
    for (int i = 0; i < threads.length; i++)
    {
      try
      {
        threads[i].join(waitTime);
        if (threads[i].isAlive())
        {
          failures.add("Hung thread: " + threads[i].getName());
          threads[i].interrupt();
          waitTime = 1000;
        }
      }
      catch (InterruptedException e)
      {
      }
    }
    for (int i = 0; i < failures.size(); i++)
    {
      logger.error("Operation failed: " + failures.get(i));
    }
    return failures;
  }

  /**
   * This test verifies that our operating environment is correct. This test
   * does not clain to be a complete test for execution ordering. Assertion:
   * Transactions with conflicting updates will be applied in the same order on
   * all backends. Plan: Run many threads with conflicting operations and verify
   * that the result is the same in both backends.
   * 
   * @throws Exception
   */
  public void testTotalOrder() throws Exception
  {
    createThreads();
    System.out.print("Enable all backends and hit enter:");
    in.readLine();

    for (int i = 0; i < 12; i++)
    {
      setPaused(true);
      waitPaused(threads.length);
      checkBackends();
      setPaused(false);
      Thread.sleep(5000);
    }
    assertEquals(0, stopThreads().size());
    checkBackends();
  }

  /**
   * Assertion: A backend can be disabled while the system is active. Plan:
   * Start activity in the system and disable a backend. The backend is enabled
   * after the activity completes and the backend state is verified.
   * 
   * @throws Exception
   */
  public void testDisableActive() throws Exception
  {
    createThreads();
    System.out.print("Enable all backends and hit enter:");
    in.readLine();

    setPaused(false);
    Thread.sleep(1000);
    System.out.print("Disable one backend and hit enter:");
    in.readLine();

    Thread.sleep(1000);
    setPaused(true);
    System.out.print("Enable the backend and hit enter:");
    in.readLine();
    setPaused(false);

    Thread.sleep(1000);

    assertEquals(0, stopThreads().size());
    checkBackends();
  }

  /**
   * Assertion: A backend can be enabled while the system is active. Plan: With
   * a backend disabled, start activity against the system and enable a backend.
   * Enable the backend and let continue for a period afterward. Stop the
   * activity and verify the results.
   * 
   * @throws Exception
   */
  public void testEnableActive() throws Exception
  {

    createThreads();
    System.out.print("Disable one backend and hit enter:");
    in.readLine();

    setPaused(false);
    Thread.sleep(1000);
    System.out.print("Enable the backend and hit enter:");
    in.readLine();
    setPaused(false);

    Thread.sleep(1000);

    assertEquals(0, stopThreads().size());
    checkBackends();
  }

  /**
   * Assertion: If a backend fails while the system is active, all client
   * activity will continue without failures. Plan: Start activity against the
   * system and abruptly stop a backend. Verify that no errors were received on
   * the test threads.
   * 
   * @throws Exception
   */
  public void testKillBackend() throws Exception
  {
    createThreads();
    System.out.print("Enable all backends and hit enter:");
    in.readLine();
    setPaused(false);
    Thread.sleep(1000);
    System.out.print("Kill a backend server and hit enter:");
    in.readLine();
    Thread.sleep(1000);
    assertEquals(0, stopThreads().size());
  }

  /**
   * Assertion: If a backend fails while the system is active, all client
   * activity will continue without failures. This case uses extra readers in
   * order to catch errors retrying read only queries. Plan: Start activity
   * against the system and abruptly stop a backend. Verify that no errors were
   * received on the test threads.
   * 
   * @throws Exception
   */
  public void testKillBackendWithManyReads() throws Exception
  {
    String[] temp = methods;
    methods = new String[temp.length + 3];
    threads = new Thread[methods.length * config.urls.length];
    Arrays.asList(temp).toArray(methods);
    int i = temp.length;
    methods[i++] = "doCallableStatementReader";
    methods[i++] = "doStatementReader";
    methods[i] = "doPreparedStatementReader";
    createThreads();
    System.out.print("Enable all backends and hit enter:");
    in.readLine();
    setPaused(false);
    Thread.sleep(1000);
    System.out.print("Kill a backend server and hit enter:");
    in.readLine();
    Thread.sleep(1000);
    assertEquals(0, stopThreads().size());
  }

  public void testBackEndError() throws Exception
  {
    createThreads();
    System.out.print("Enable all backends and hit enter:");
    in.readLine();
    setPaused(false);
    Thread.sleep(1000);
    Connection c1 = null;
    Connection c2 = null;
    String url = props.getProperty("backend1.url");
    try
    {
      logger.debug("Connecting to: " + url);
      c1 = getConnection(url);
      Statement s = c1.createStatement();
      s.executeUpdate("insert into many_threads values(1999, 'hello', 9991)");
      if (!c1.getAutoCommit())
      {
        c1.commit();
      }
      logger.debug("Connecting to: " + config.url);
      c2 = getConnection(config.urlone);
      s = c2.createStatement();
      s.executeUpdate("update many_threads set value = 1999 where a = 1999");
      if (!c2.getAutoCommit())
      {
        c2.commit();
      }
      Thread.sleep(1000);
      assertEquals(0, stopThreads().size());
      s.setQueryTimeout(2);
      s.execute("update many_threads set b = b || 'x' where a = 1");
      if (!c2.getAutoCommit())
      {
        c2.commit();
      }
    }
    finally
    {
      close(c1);
      close(c2);
    }

  }
}
